\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
\newcommand\tab[1][0.5cm]{\hspace*{#1}}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{textcomp}
\usepackage{tabularx}
\usepackage{xcolor}
\usepackage{url}
\usepackage[style=ieee,backend=biber]{biblatex}
\usepackage{float}
\usepackage[T1]{fontenc}
\usepackage[scaled]{beramono}

\addbibresource{ref.bib}

\usepackage{color}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}
%\lstset { %
%	language=C,
%	backgroundcolor=\color{black!5}, 
%	basicstyle=\footnotesize,
%}
\lstset{language=C,
	showspaces=false,
	showtabs=false,
	breaklines=true,
	showstringspaces=false,
	breakatwhitespace=true,
	escapeinside={(*@}{@*)},
	commentstyle=\color{greencomments},
	keywordstyle=\color{bluekeywords},
	stringstyle=\color{redstrings},
	basicstyle=\ttfamily
}
    
\begin{document}

\title{CoE 135 (Operating Systems): Problem Set 2\\
}

\author{\IEEEauthorblockN{Salmon, Paulino III I. }
	\IEEEauthorblockA{\textit{2015-11557}\\
	paulino.salmon@eee.upd.edu.ph}}		
\maketitle

\section{Honor Code}
I pledge that I answered all the items in this Problem Set to the best of my understanding,
and with the aid of properly cited resources and collaborators in problems I could not solve on my
own. I made sure that I cited all resources and stated the names of all those who guided me in
answering all the items along with their invaluable contributions. \\
\tab - Paulino I. Salmon III, 2015-11557

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Address Translation}
\begin{itemize}
	\item \textit{A}. (10 pts) Consider the following Segment Table:
		\begin{table}[H]
			\centering
			\begin{tabular}{lll}
				\textbf{Segment Number} & \textbf{Base} & \textbf{Length} \\
				0 & 220 & 500 \\
				1 & 2000 & 15 \\
				2 & 100 & 90 \\
				3 & 1333 & 555 \\
				4 & 1969 & 71
			\end{tabular}
		\end{table}
	
	What are the physical addresses of the following logical addresses given the segment table
	above?
	\begin{itemize} 
		\item {Segment 0, Address 430} \\	
		430 < 500 (Valid), 430 + 220 = \textbf{650}
		\item {Segment 1, Address 10} \\
		10 < 15 (Valid), 10 + 2000 = \textbf{2010} 
		\item {Segment 2, Address 500} \\
		500 !< 90 \textbf{(Invalid)} 
		\item {Segment 3, Address 400} \\
		400 < 555 (Valid), 400 + 1333 = \textbf{1733}
		\item {Segment 4, Address 96} \\
		96 !< 71 \textbf{(Invalid)}
	\end{itemize} 

\begin{center}
\textbf{Self Grade For \#: 4}
\end{center}

\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{itemize}
	\item \textit{B}. (5 pts) A computing machine provides its users with a virtual-memory space of $2^{32}$ bytes.
	The computer has $2^{18}$ bytes of physical memory. The virtual memory is implemented by a
	paging scheme, and the page size is 4096 bytes. A user process requests access to the virtual
	address 11123456. Determine and explain how the system establishes the corresponding physical
	address.
	\begin{itemize} 
		\item Page sizes are typically represented in powers of two for the reason that it's easier to divide the binary format of a number to represent both the page number and the page offset. If it is given that the page size is $log_{2}(4096) = 2^{12}$, the remaining bits will therefore be given to the page table, $32 - 12 = 20; 2^{20}$. 
	\end{itemize}

\begin{center}
\textbf{Self Grade For \#: 3}
\end{center}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{itemize}
	\item \textit{C}. (5 pts) You are given a demand-paged memory management scheme. It takes 10ms to service
	a page fault if an empty page is available or the replaced page is not modified, and it takes 18ms
	if the replaced page is modified. Memory access time takes 80ns. If the page to be replaced is
	modified 70\% of the time, what is the maximum acceptable page-fault rate for an effective
	access time of 250ns?
	\begin{itemize} 
		\item Let \textit{n} be equal to the page-fault rate (miss ratio)
		\begin{center}
		250ns = (\textit{n})[(10ms)(0.3) + (18ms)(0.7) + 80ns] + (1-\textit{n})(80ns) \\
		\end{center}
		Solving for \textit{n} we get: \\
		\begin{equation}
		n = 1.0897435\cdot10^{-5}
		\end{equation}
	\end{itemize}
	
	\begin{center}
		\textbf{Self Grade For \#: 4}
	\end{center}
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Demand Paging}
\begin{itemize}
	\item (20 pts) Demand paging is a mechanism wherein we use a page replacement algorithm to manage the
	pages loaded onto the physical memory frames. Suppose that a newly created process is given 4
	frames by the OS, and generates the following page references below:
	\begin{equation}
	1 2 3 4 2 1 3 5 1 2 3 4 1 5 1 3 2 4
	\end{equation}
	
(5 pts) How many page faults would occur with a FIFO (First-In-First-Out) page
replacement policy? Place an 'X' in each box corresponding to a page fault. Place the total
number of page faults under the \# column.
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|}
		\hline
		\textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{2} & \textbf{1} & \textbf{3} & \textbf{5} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} \\ \hline
		X & X & X & X &  &  &  & X & X & X & X & X \\ \hline
	\end{tabular}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|l|l|l|l|}
		\hline
		\textbf{1} & \textbf{5} & \textbf{1} & \textbf{3} & \textbf{2} & \textbf{4} & \textbf{\#} \\ \hline
		 & X & X &  & X & X & 13 \\ \hline
	\end{tabular}
\end{table}

\begin{center}
	\textbf{Self Grade For \#: 4}
\end{center}

(5 pts) How many page faults would occur with LRU (Least Recently Used) page
replacement policy? Place an 'X' in each box corresponding to a page fault. Place the total
number of page faults under the \# column.
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|}
		\hline
		\textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{2} & \textbf{1} & \textbf{3} & \textbf{5} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} \\ \hline
		X & X & X & X &  &  &  & X &  &  &  & X \\ \hline
	\end{tabular}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|l|l|l|l|}
		\hline
		\textbf{1} & \textbf{5} & \textbf{1} & \textbf{3} & \textbf{2} & \textbf{4} & \textbf{\#} \\ \hline
		& X &  &  & X & X & 9 \\ \hline
	\end{tabular}
\end{table}

\begin{center}
	\textbf{Self Grade For \#: 4}
\end{center}

(c) (5 pts) How many page faults would occur with LFU (Least Frequently Used) page
replacement policy? Place an 'X' in each box corresponding to a page fault. Place the total number
of page faults under the \# column.
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|}
		\hline
		\textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{2} & \textbf{1} & \textbf{3} & \textbf{5} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} \\ \hline
		X & X & X & X &  &  &  & X &  &  &  & X \\ \hline
	\end{tabular}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|l|l|l|l|}
		\hline
		\textbf{1} & \textbf{5} & \textbf{1} & \textbf{3} & \textbf{2} & \textbf{4} & \textbf{\#} \\ \hline
		& X &  &  &  & X & 8 \\ \hline
	\end{tabular}
\end{table}

\begin{center}
	\textbf{Self Grade For \#: 4}
\end{center}

(5 pts) How many page faults would occur with clock replacement/second chance
replacement policy? Place an 'X' in each box corresponding to a page fault. Place the total number
of page faults under the \# column.
\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|l|l|l|l|l|l|l|l|l|}
		\hline
		\textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} & \textbf{2} & \textbf{1} & \textbf{3} & \textbf{5} & \textbf{1} & \textbf{2} & \textbf{3} & \textbf{4} \\ \hline
		X & X & X & X &  &  &  & X & X & X & X & X \\ \hline
	\end{tabular}
\end{table}

\begin{table}[H]
	\centering
	\begin{tabular}{|l|l|l|l|l|l|l|}
		\hline
		\textbf{1} & \textbf{5} & \textbf{1} & \textbf{3} & \textbf{2} & \textbf{4} & \textbf{\#} \\ \hline
		& X &  &  & X &  & 11 \\ \hline
	\end{tabular}
\end{table}

\begin{center}
	\textbf{Self Grade For \#: 3}
\end{center}

\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reader-Writer Problem}
\begin{itemize}
\item (20 pts) Reader-Writer Problem. You are given the Reader-Writer pseudocode below for
accessing a shared resource:
executed.
\begin{lstlisting}
readerThreadRoutine() {
	lock.acquire();
	while (activeWrite > 0) {
		waitRead++;
		okToRead.wait(&lock);
		waitRead--;
	}
	activeRead++;
	lock.release();
	
	AccessResource(ReadOnly);
	
	lock.acquire();
	activeRead--;
	if (activeRead == 0 && waitWrite > 0)
		okToWrite.signal();
	lock.release();
}

writerThreadRoutine() {
	lock.acquire();
	while ( (activeWrite + activeRead + waitRead) > 0 ) {
		waitWrite++;
		okToWrite.wait(&lock);
		waitWrite--;
	}
	activeWrite++;
	
	lock.release();
	
	AccessResource(ReadWrite);
	
	lock.acquire();
	activeWrite--;
	if (waitRead > 0) {
		okToRead.broadcast();
	} else if (waitWrite > 0) {
		okToWrite.signal();
	}
	lock.release();
}
\end{lstlisting}

The code snippet above uses two condition variables, one for waiting readers and another for
waiting writers. Suppose that all of the requests arrive in this order with a very small time
interval between them. Note that none of these threads have started yet:
\begin{center}
W1 R1 R2 R3 W2 W3 R4 R5 R6 W4 R7 W5 W6 R8 R9 W7 R10
\end{center}

(5 pts) In what order would the above code process the above requests? If you have a group
of requests that are equivalent (unordered), indicate this by surrounding the equivalent/
unordered requests with square brackets '[]'. You can assume that the wait queues for condition
variables are FIFO in nature (i.e. signal() wakes up the oldest thread on the queue). Explain your
answer.
\begin{itemize}
	\item The above code prioritizes writes over reads as implemented in the \textit{writerThreadRoutine()} function. Therefore, the following sequence will be executed:
	\begin{center}
		W1 W2 W3 W4 W5 W6 [R1 R2 R3 R4 R5 R6 R7 R8 R9 R10]
	\end{center}
\begin{center}
	\textbf{Self Grade For \#: 3}
\end{center}
\end{itemize}

(3 pts) How would the order of processing the above requests change if W1 was currently
running when the other requests arrive? Explain your answer.

\begin{itemize}
	\item As writes are still prioritized over asynchronous reads, the sequence will remain the same:
		\begin{center}
		W1 W2 W3 W4 W5 W6 [R1 R2 R3 R4 R5 R6 R7 R8 R9 R10]
	\end{center}
	\begin{center}
		\textbf{Self Grade For \#: 2}
	\end{center}
\end{itemize}

(c) (3 pts) What will be prioritised by the code snippet above? Is it the readers or the writers?
Explain your answer.

\begin{itemize}
	\item The code prioritizes the writers first, as the condition gets trapped in a while loop and is locked until both the \textit{activeWrite} and the \textit{activeRead} conditions are triggered (decremented or incremented) properly to break the lock.
		\begin{center}
		\textbf{Self Grade For \#: 3}
	\end{center}
\end{itemize}

(d) (3 pts) How does the code snippet above ensure that if activeRead > 0, then
activeWrite == 0?

\begin{itemize}
	\item 
\end{itemize}

(e) (3 pts) How does the code snippet above ensure that there can only be one writer at a time,
and that if activeWrite == 1, then activeRead == 0?

\begin{itemize}
	\item 
\end{itemize}

(f) (3 pts) Why does the reader not need to check if waitRead > 0?

\begin{itemize}
	\item 
\end{itemize}

\begin{center}
	\textbf{Self Grade For \#: 4}
\end{center}
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interprocess Communication}
(20 pts) You are given the code template below:
\begin{lstlisting}
(1) #include <stdio.h>
(2) #include <stdlib.h>
(3) #include <string.h>
(4) #include <stdint.h>
(5) #include <stdbool.h>

(6) #include <assert.h>
(7) #include <unistd.h>
(8) #include <fcntl.h>
(9) #include <sys/mman.h>
(10)#include <sys/stat.h>
(11)#include <sys/types.h>
(12)#include <sys/wait.h>
(13)
(14)#define PAGESIZE 4096
(15)#define CTRMAX 1000000
(16)
(17)#define increment_val(ptr) (*ptr) += 1
(18)
(19)int main()
(20){
(21)	uint32_t *smem = mmap(NULL, PAGESIZE,
(22)	PROT_READ | PROT_WRITE,
(23)	MAP_SHARED | MAP_ANONYMOUS, -1, 0);
(24)
(25)	assert(smem != MAP_FAILED);
(26)
(27)	*smem = 10;
(28)
(29)	pid_t pid;
(30)
(31)	pid = fork();
(32)	assert(pid >= 0);
(33)
(34)	if (pid) {
(35)		for (int ctr = 0; ctr < CTRMAX; ++ctr)
(36)			increment_val(smem);
(37)		wait(NULL);
(38)	} else {
(39)		for (int ctr = 0; ctr < CTRMAX; ++ctr)
(40)			increment_val(smem);
(41)	}
(42)
(43)	if (pid) {
(44)		printf("Data: %d\n", *smem);
(45)		int unmap_res = munmap(smem, PAGESIZE);
(46)		assert(unmap_res == 0);
(47)	}
(48)
(49)	return 0;
(50)}
\end{lstlisting}

\begin{itemize}
\item \textit{A}. (3 pts) The code snippet above will rarely print the value 2000010 at line 45, if at all, every
time the code is executed. What is the reason behind this anomaly?
\begin{itemize} 
	\item Hi
	
	\begin{center}
		\textbf{Self Grade For \#: 4}
	\end{center}
\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textit{B}. (6 pts) Propose a modification to the given code template to ensure that the value 2000010 is
	always printed at line 45 (without printing it directly!).
	\begin{itemize} 
	\item Hi
		
		\begin{center}
			\textbf{Self Grade For \#: 4}
		\end{center}
	\end{itemize}
\end{itemize}

\begin{itemize}
	\item \textit{C}. (5 pts) If the program above were to be implemented using message passing API, would the
	anomaly still occur without the modification needed for shared memory API? Explain your
	answer.
	\begin{itemize} 
	\item Hi
		\begin{center}
			\textbf{Self Grade For \#: 4}
		\end{center}
	\end{itemize}
\end{itemize}

\begin{itemize}
\item \textit{D}. (6 pts) Present a reimplementation of the code template provided using message passing
API.
	\begin{itemize} 
	\item Hi
		\begin{center}
			\textbf{Self Grade For \#: 4}
		\end{center}
	\end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Overuse of Threads and Processes}
\begin{itemize}
	\item (20 pts) Discuss two different reasons as to why the overuse
	of threads/use of too many threads is bad. Discuss two different reasons as to why the overuse
	or processes/use of too many processes is bad. Give an example for each reason.
	\begin{itemize} 
		\item Hi
		\begin{center}
			\textbf{Self Grade For \#: 4}
		\end{center}
	\end{itemize}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Process States}
\begin{itemize}
	\item (10 pts) Determine which state the processes below belong to given their current
	situation.
	\begin{itemize} 
		\item Hi
		\begin{center}
			\textbf{Self Grade For \#: 4}
		\end{center}
	\end{itemize}
\end{itemize}

\printbibliography
\end{document}
